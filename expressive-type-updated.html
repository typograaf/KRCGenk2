<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KRCG Graphic Generator</title>
    <style>
        @font-face {
            font-family: 'Genk';
            src: url('Assets/genk260115-RegularRounded.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }

        @font-face {
            font-family: 'ABC Arizona Sans';
            src: url('Assets/ABC%20Arizona%20Sans/ABCArizonaSans-Regular-Trial.woff2') format('woff2'),
                 url('Assets/ABC%20Arizona%20Sans/ABCArizonaSans-Regular-Trial.woff') format('woff');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'ABC Arizona Sans';
            src: url('Assets/ABC%20Arizona%20Sans/ABCArizonaSans-Bold-Trial.woff2') format('woff2'),
                 url('Assets/ABC%20Arizona%20Sans/ABCArizonaSans-Bold-Trial.woff') format('woff');
            font-weight: 700;
            font-style: normal;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'ABC Arizona Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            background: #001550;
            color: #82CDFF;
            display: flex;
            gap: 24px;
            padding: 24px;
        }

        /* Left Sidebar */
        .sidebar-left {
            width: 200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            flex-shrink: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .sidebar-left-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Right Sidebar */
        .sidebar-right {
            width: 200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-shrink: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Header/Logo */
        .header {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .header-icon {
            width: 14px;
            height: 18px;
            flex-shrink: 0;
        }

        .header-title {
            font-size: 12px;
            color: #82cdff;
        }

        /* Panel Styles */
        .panel {
            background: #0d2159;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
        }

        .panel-dark {
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
        }

        /* Text Input */
        .text-input {
            width: 100%;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            color: #82CDFF;
            font-family: inherit;
            font-size: 12px;
            letter-spacing: 0.12px;
        }
        .text-input:focus {
            outline: none;
            border-color: #82CDFF;
        }
        .text-input::placeholder {
            color: #82CDFF;
            opacity: 0.6;
        }

        /* Control Labels */
        .control-label {
            font-size: 12px;
            color: #82CDFF;
            margin-bottom: 12px;
            display: block;
        }

        /* Color Swatches */
        .color-section {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .color-swatches {
            display: flex;
            gap: 6px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .color-swatch:hover,
        .color-swatch.active {
            border-color: #334473;
        }

        /* Grid Toggle */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
        }

        .toggle-label {
            font-size: 12px;
            color: #82CDFF;
        }

        .toggle-checkbox {
            display: none;
        }

        .toggle-box {
            width: 16px;
            height: 16px;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .toggle-box:hover {
            border-color: #82CDFF;
        }

        .toggle-box svg {
            width: 7px;
            height: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .toggle-checkbox:checked + .toggle-box svg {
            opacity: 1;
        }

        /* Repeat Controls */
        .repeat-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .repeat-btn {
            width: 20px;
            height: 20px;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 4px;
            color: #82CDFF;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .repeat-btn:hover {
            border-color: #82CDFF;
        }

        .repeat-value {
            font-size: 11px;
            color: #82CDFF;
            min-width: 24px;
            text-align: center;
        }

        /* Slider Styles */
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .slider-label {
            font-size: 12px;
            color: #82CDFF;
        }

        .slider-value {
            font-size: 8px;
            font-weight: bold;
            color: #82CDFF;
            background: transparent;
            border: none;
            text-align: right;
            width: 40px;
        }

        .slider-value:focus {
            outline: none;
            color: #FFFFFF;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider-track {
            flex: 1;
            height: 2px;
            background: #1a2c62;
            border-radius: 12px;
            position: relative;
            display: flex;
            align-items: center;
        }

        .slider {
            width: 100%;
            height: 12px;
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .slider::-webkit-slider-runnable-track {
            height: 2px;
            background: #1a2c62;
            border-radius: 12px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #82CDFF;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -5px;
        }

        .reset-btn {
            width: 16px;
            height: 16px;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .reset-btn:hover {
            border-color: #82CDFF;
        }

        .reset-btn svg {
            width: 7px;
            height: 9px;
        }

        /* Canvas Size Buttons */
        .size-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .size-btn {
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            color: #82CDFF;
            font-size: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .size-btn:hover {
            border-color: #82CDFF;
        }

        .size-btn.active {
            border-color: #82CDFF;
            background: #82CDFF;
            color: #001550;
        }

        /* Easing Curve Editor */
        .easing-container {
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            position: relative;
        }

        #easingCanvas {
            width: 100%;
            aspect-ratio: 1;
            display: block;
            cursor: crosshair;
        }

        .easing-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #82CDFF;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .easing-input {
            width: 100%;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            color: #82CDFF;
            font-size: 8px;
            font-weight: bold;
            text-align: center;
            margin-top: 12px;
        }

        .easing-input:focus {
            outline: none;
            border-color: #82CDFF;
        }

        /* Output Buttons */
        .output-buttons {
            display: flex;
            gap: 6px;
        }

        .output-btn {
            flex: 1;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            color: #82CDFF;
            font-size: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .output-btn:hover {
            background: #82CDFF;
            color: #001550;
        }

        .output-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Canvas Container */
        #canvas-container {
            flex: 1;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background: #001550;
        }

        #canvas-container canvas {
            display: block;
            transform-origin: center center;
            border-radius: 12px;
        }

        #grid-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            pointer-events: none;
            display: none;
            transform-origin: center center;
            z-index: 10;
        }

        #grid-overlay.visible {
            display: block;
        }

        /* Branding Footer */
        .branding {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .branding-icon {
            width: 17px;
            height: 17px;
        }

        .branding-text {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .branding-label {
            font-size: 7px;
            color: #82CDFF;
            letter-spacing: -0.14px;
        }

        .branding-name {
            font-size: 14px;
            font-weight: 600;
            color: #82CDFF;
            text-transform: uppercase;
            letter-spacing: 0.14px;
            display: flex;
            align-items: flex-start;
        }

        .branding-copyright {
            font-size: 4px;
            vertical-align: super;
            margin-left: 1px;
        }

        /* Multi-slider panels */
        .slider-panel {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        /* Mobile Responsive */
        @media (max-width: 900px) {
            html, body {
                height: 100%;
            }

            body {
                flex-direction: column;
                padding: 0;
                gap: 0;
                overflow-y: auto;
                overflow-x: hidden;
            }

            #canvas-container {
                width: auto;
                min-height: 280px;
                height: 50vh;
                flex-shrink: 0;
                order: -1;
                border-radius: 20px;
                position: sticky;
                top: 0;
                margin: 0;
                z-index: 200;
                overflow: visible;
                background: transparent;
                pointer-events: none;
            }

            #canvas-container canvas {
                border-radius: 20px;
                pointer-events: auto;
            }

            .sidebar-left {
                width: 100%;
                height: auto;
                padding: 0;
                flex-shrink: 0;
                margin-top: -25vh;
                padding-top: calc(50vh - 40px);
            }

            .sidebar-left-content {
                gap: 10px;
                padding: 16px;
            }

            .sidebar-right {
                width: 100%;
                height: auto;
                padding: 16px;
                flex-shrink: 0;
            }

            .branding {
                margin-top: 16px;
                padding: 16px;
            }

            .panel {
                padding: 10px;
            }

            .color-section {
                gap: 16px;
            }

            .slider-panel {
                gap: 16px;
            }

            .size-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 900px) {
            .control-label,
            .slider-label,
            .toggle-label {
                font-size: 14px;
            }

            .slider-value {
                font-size: 12px;
            }

            .size-btn {
                font-size: 11px;
                padding: 14px 12px;
            }

            .output-btn {
                font-size: 11px;
                padding: 14px;
            }

            .text-input {
                font-size: 14px;
                padding: 14px;
            }

            .easing-input {
                font-size: 11px;
                padding: 14px;
            }

            .color-swatch {
                width: 32px;
                height: 32px;
            }

            .slider {
                height: 20px;
            }

            .slider::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
                margin-top: -8px;
            }

            .reset-btn,
            .toggle-box {
                width: 24px;
                height: 24px;
            }

            .reset-btn svg {
                width: 10px;
                height: 12px;
            }

            .toggle-box svg {
                width: 10px;
                height: 6px;
            }

            .header-title {
                font-size: 14px;
            }

            .header-icon {
                width: 18px;
                height: 23px;
            }

            #easingCanvas {
                min-height: 180px;
            }
        }

        @media (max-width: 480px) {
            #canvas-container {
                height: 45vh;
                min-height: 240px;
            }

            .sidebar-left {
                margin-top: -22vh;
                padding-top: calc(45vh - 30px);
            }

            .sidebar-left-content {
                padding: 12px;
            }

            .sidebar-right {
                padding: 12px;
            }

            .branding {
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Left Sidebar -->
    <div class="sidebar-left">
        <div class="sidebar-left-content">
            <!-- Header -->
            <div class="header">
                <svg class="header-icon" width="14" height="18" viewBox="0 0 14 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6.71299 17.291C6.14792 17.291 5.31163 16.9181 4.2041 16.1722C3.11917 15.4263 2.14725 14.5109 1.28835 13.426C0.429451 12.3411 0 11.3013 0 10.3068V2.5767C0 2.10205 0.226027 1.77431 0.67808 1.59349C1.44657 1.25445 2.44109 0.904106 3.66163 0.542463C4.90478 0.180821 5.9219 0 6.71299 0C7.50408 0 8.5099 0.180821 9.73045 0.542463C10.9736 0.904106 11.9794 1.25445 12.7479 1.59349C13.2 1.77431 13.426 2.10205 13.426 2.5767V5.9332L10.4763 5.0856V2.5428L11.5274 3.86505C10.6459 3.50341 9.75305 3.19828 8.84894 2.94965C7.94484 2.70102 7.23285 2.5767 6.71299 2.5767C6.19313 2.5767 5.48115 2.70102 4.57704 2.94965C3.67293 3.19828 2.78013 3.50341 1.89862 3.86505L2.94965 2.71232V10.1034C2.94965 10.4424 3.09657 10.8719 3.3904 11.3917C3.70684 11.889 4.12499 12.3863 4.64485 12.8835C5.16471 13.3582 5.71847 13.7311 6.30614 14.0023L6.44176 14.0363C6.55477 14.0815 6.64518 14.1041 6.71299 14.1041C6.7808 14.1041 6.87121 14.0815 6.98422 14.0363L7.11984 14.0023C7.70751 13.7311 8.26127 13.3582 8.78113 12.8835C9.301 12.3863 9.70784 11.889 10.0017 11.3917C10.3181 10.8719 10.4763 10.4424 10.4763 10.1034V8.13696L12.1715 9.89997H6.98422L5.62806 7.25545H13.426V10.3068C13.426 11.3013 12.9965 12.3411 12.1376 13.426C11.2787 14.5109 10.2955 15.4263 9.18798 16.1722C8.10306 16.9181 7.27806 17.291 6.71299 17.291Z" fill="#86D9FF"/>
                </svg>
                <span class="header-title">KRCG Graphic Generator</span>
            </div>

            <!-- Text Input -->
            <input type="text" class="text-input" id="textInput" value="KRC GENK  " placeholder="TEXT GOES HERE...">

            <!-- Colors Panel -->
            <div class="panel">
                <div class="color-section">
                    <div>
                        <span class="control-label">Background Colour</span>
                        <div class="color-swatches" id="bgColorSwatches">
                            <div class="color-swatch active" data-color="82CDFF" style="background-color: #82CDFF;"></div>
                            <div class="color-swatch" data-color="07144a" style="background-color: #07144a;"></div>
                            <div class="color-swatch" data-color="1f3ab6" style="background-color: #1f3ab6;"></div>
                            <div class="color-swatch" data-color="FFFFFF" style="background-color: #FFFFFF;"></div>
                        </div>
                    </div>
                    <div>
                        <span class="control-label">Text Colour</span>
                        <div class="color-swatches" id="fgColorSwatches">
                            <div class="color-swatch" data-color="82CDFF" style="background-color: #82CDFF;"></div>
                            <div class="color-swatch active" data-color="07144a" style="background-color: #07144a;"></div>
                            <div class="color-swatch" data-color="1f3ab6" style="background-color: #1f3ab6;"></div>
                            <div class="color-swatch" data-color="FFFFFF" style="background-color: #FFFFFF;"></div>
                        </div>
                    </div>
                    <div class="toggle-row">
                        <span class="toggle-label">Show 3×3 Grid</span>
                        <input type="checkbox" class="toggle-checkbox" id="gridToggle">
                        <label class="toggle-box" for="gridToggle">
                            <svg viewBox="0 0 7 4" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M6.5 0.5L3.5 3.5L0.5 0.5" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </label>
                    </div>
                    <div class="toggle-row">
                        <span class="toggle-label">Vertical Mode</span>
                        <input type="checkbox" class="toggle-checkbox" id="verticalToggle">
                        <label class="toggle-box" for="verticalToggle">
                            <svg viewBox="0 0 7 4" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M6.5 0.5L3.5 3.5L0.5 0.5" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </label>
                    </div>
                    <div class="toggle-row" id="repeatRow">
                        <span class="toggle-label">Repeat</span>
                        <div class="repeat-controls">
                            <button class="repeat-btn" id="repeatMinus">−</button>
                            <span class="repeat-value" id="repeatValue">2×</span>
                            <button class="repeat-btn" id="repeatPlus">+</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Shape Size & Corner Radius -->
            <div class="panel">
                <div class="slider-panel">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Shape Size</span>
                            <input type="text" class="slider-value" id="sizeValue" value="280">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="sizeSlider" min="150" max="450" value="280">
                            </div>
                            <button class="reset-btn" data-reset="size">
                                <svg viewBox="0 0 7 9" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M4.30909 5.75766H6.33126V7.77983M2.69135 2.52218H0.669174V0.5M6.50014 2.92799C6.27338 2.36673 5.89371 1.88035 5.4043 1.52412C4.91489 1.16789 4.33544 0.956009 3.73166 0.912729C3.12788 0.86945 2.52394 0.996405 1.98872 1.27919C1.45351 1.56197 1.00842 1.98935 0.70393 2.51252M0.500132 5.35204C0.726893 5.91329 1.10655 6.39967 1.59597 6.7559C2.08538 7.11213 2.66542 7.32374 3.2692 7.36702C3.87298 7.4103 4.47643 7.28337 5.01164 7.00058C5.54686 6.7178 5.99164 6.2905 6.29613 5.76733" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Corner Radius</span>
                            <input type="text" class="slider-value" id="radiusValue" value="60">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="radiusSlider" min="15" max="130" value="60">
                            </div>
                            <button class="reset-btn" data-reset="radius">
                                <svg viewBox="0 0 7 9" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M4.30909 5.75766H6.33126V7.77983M2.69135 2.52218H0.669174V0.5M6.50014 2.92799C6.27338 2.36673 5.89371 1.88035 5.4043 1.52412C4.91489 1.16789 4.33544 0.956009 3.73166 0.912729C3.12788 0.86945 2.52394 0.996405 1.98872 1.27919C1.45351 1.56197 1.00842 1.98935 0.70393 2.51252M0.500132 5.35204C0.726893 5.91329 1.10655 6.39967 1.59597 6.7559C2.08538 7.11213 2.66542 7.32374 3.2692 7.36702C3.87298 7.4103 4.47643 7.28337 5.01164 7.00058C5.54686 6.7178 5.99164 6.2905 6.29613 5.76733" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Rotation Controls -->
            <div class="panel">
                <div class="slider-panel">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Rotation X</span>
                            <input type="text" class="slider-value" id="rotXValue" value="-45">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="rotXSlider" min="-90" max="90" value="-45">
                            </div>
                            <button class="reset-btn" data-reset="rotX">
                                <svg viewBox="0 0 7 9" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M4.30909 5.75766H6.33126V7.77983M2.69135 2.52218H0.669174V0.5M6.50014 2.92799C6.27338 2.36673 5.89371 1.88035 5.4043 1.52412C4.91489 1.16789 4.33544 0.956009 3.73166 0.912729C3.12788 0.86945 2.52394 0.996405 1.98872 1.27919C1.45351 1.56197 1.00842 1.98935 0.70393 2.51252M0.500132 5.35204C0.726893 5.91329 1.10655 6.39967 1.59597 6.7559C2.08538 7.11213 2.66542 7.32374 3.2692 7.36702C3.87298 7.4103 4.47643 7.28337 5.01164 7.00058C5.54686 6.7178 5.99164 6.2905 6.29613 5.76733" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Rotation Y</span>
                            <input type="text" class="slider-value" id="rotYValue" value="0">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="rotYSlider" min="-180" max="180" value="0">
                            </div>
                            <button class="reset-btn" data-reset="rotY">
                                <svg viewBox="0 0 7 9" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M4.30909 5.75766H6.33126V7.77983M2.69135 2.52218H0.669174V0.5M6.50014 2.92799C6.27338 2.36673 5.89371 1.88035 5.4043 1.52412C4.91489 1.16789 4.33544 0.956009 3.73166 0.912729C3.12788 0.86945 2.52394 0.996405 1.98872 1.27919C1.45351 1.56197 1.00842 1.98935 0.70393 2.51252M0.500132 5.35204C0.726893 5.91329 1.10655 6.39967 1.59597 6.7559C2.08538 7.11213 2.66542 7.32374 3.2692 7.36702C3.87298 7.4103 4.47643 7.28337 5.01164 7.00058C5.54686 6.7178 5.99164 6.2905 6.29613 5.76733" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Rotation Z</span>
                            <input type="text" class="slider-value" id="rotZValue" value="-45">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="rotZSlider" min="-180" max="180" value="-45">
                            </div>
                            <button class="reset-btn" data-reset="rotZ">
                                <svg viewBox="0 0 7 9" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M4.30909 5.75766H6.33126V7.77983M2.69135 2.52218H0.669174V0.5M6.50014 2.92799C6.27338 2.36673 5.89371 1.88035 5.4043 1.52412C4.91489 1.16789 4.33544 0.956009 3.73166 0.912729C3.12788 0.86945 2.52394 0.996405 1.98872 1.27919C1.45351 1.56197 1.00842 1.98935 0.70393 2.51252M0.500132 5.35204C0.726893 5.91329 1.10655 6.39967 1.59597 6.7559C2.08538 7.11213 2.66542 7.32374 3.2692 7.36702C3.87298 7.4103 4.47643 7.28337 5.01164 7.00058C5.54686 6.7178 5.99164 6.2905 6.29613 5.76733" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Offset Controls -->
            <div class="panel">
                <div class="slider-panel">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Offset X</span>
                            <input type="text" class="slider-value" id="offsetXValue" value="0">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="offsetXSlider" min="-500" max="500" value="0">
                            </div>
                            <button class="reset-btn" data-reset="offsetX">
                                <svg viewBox="0 0 7 9" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M4.30909 5.75766H6.33126V7.77983M2.69135 2.52218H0.669174V0.5M6.50014 2.92799C6.27338 2.36673 5.89371 1.88035 5.4043 1.52412C4.91489 1.16789 4.33544 0.956009 3.73166 0.912729C3.12788 0.86945 2.52394 0.996405 1.98872 1.27919C1.45351 1.56197 1.00842 1.98935 0.70393 2.51252M0.500132 5.35204C0.726893 5.91329 1.10655 6.39967 1.59597 6.7559C2.08538 7.11213 2.66542 7.32374 3.2692 7.36702C3.87298 7.4103 4.47643 7.28337 5.01164 7.00058C5.54686 6.7178 5.99164 6.2905 6.29613 5.76733" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Offset Y</span>
                            <input type="text" class="slider-value" id="offsetYValue" value="0">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="offsetYSlider" min="-500" max="500" value="0">
                            </div>
                            <button class="reset-btn" data-reset="offsetY">
                                <svg viewBox="0 0 7 9" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M4.30909 5.75766H6.33126V7.77983M2.69135 2.52218H0.669174V0.5M6.50014 2.92799C6.27338 2.36673 5.89371 1.88035 5.4043 1.52412C4.91489 1.16789 4.33544 0.956009 3.73166 0.912729C3.12788 0.86945 2.52394 0.996405 1.98872 1.27919C1.45351 1.56197 1.00842 1.98935 0.70393 2.51252M0.500132 5.35204C0.726893 5.91329 1.10655 6.39967 1.59597 6.7559C2.08538 7.11213 2.66542 7.32374 3.2692 7.36702C3.87298 7.4103 4.47643 7.28337 5.01164 7.00058C5.54686 6.7178 5.99164 6.2905 6.29613 5.76733" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Branding Footer -->
        <div class="branding">
            <img src="Assets/graphic%20tool%20by%20typograaf.svg" alt="A Graphic Tool by Typograaf" style="height: 21px;">
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container">
        <svg id="grid-overlay"></svg>
    </div>

    <!-- Right Sidebar -->
    <div class="sidebar-right">
        <!-- Canvas Size -->
        <div class="panel">
            <span class="control-label">Canvas Size</span>
            <div class="size-grid" id="sizeButtons">
                <button class="size-btn active" data-size="1920x1080">1920×1080</button>
                <button class="size-btn" data-size="1080x1350">1080×1350</button>
                <button class="size-btn" data-size="1080x1920">1080×1920</button>
                <button class="size-btn" data-size="1920x1920">1920×1920</button>
            </div>
        </div>

        <!-- Animation Speed -->
        <div class="panel">
            <div class="slider-group">
                <div class="slider-header">
                    <span class="slider-label">Animation Speed</span>
                    <input type="text" class="slider-value" id="speedValue" value="0.5">
                </div>
                <div class="slider-row">
                    <div class="slider-track">
                        <input type="range" class="slider" id="speedSlider" min="0" max="2" step="0.1" value="0.5">
                    </div>
                    <button class="reset-btn" data-reset="speed">
                        <svg viewBox="0 0 7 9" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M4.30909 5.75766H6.33126V7.77983M2.69135 2.52218H0.669174V0.5M6.50014 2.92799C6.27338 2.36673 5.89371 1.88035 5.4043 1.52412C4.91489 1.16789 4.33544 0.956009 3.73166 0.912729C3.12788 0.86945 2.52394 0.996405 1.98872 1.27919C1.45351 1.56197 1.00842 1.98935 0.70393 2.51252M0.500132 5.35204C0.726893 5.91329 1.10655 6.39967 1.59597 6.7559C2.08538 7.11213 2.66542 7.32374 3.2692 7.36702C3.87298 7.4103 4.47643 7.28337 5.01164 7.00058C5.54686 6.7178 5.99164 6.2905 6.29613 5.76733" stroke="#82CDFF" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Easing Curve -->
        <div class="panel">
            <span class="control-label">Easing Curve</span>
            <div class="easing-container">
                <canvas id="easingCanvas" width="152" height="152"></canvas>
            </div>
            <input type="text" class="easing-input" id="easingInput" value="0.25, 0.25, 0.75, 0.75">
        </div>

        <!-- Output -->
        <div class="panel">
            <span class="control-label">Output</span>
            <div class="output-buttons">
                <button class="output-btn" id="exportPNG">PNG</button>
                <button class="output-btn" id="exportMP4">MP4</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import * as mp4Muxer from 'https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/+esm';
        window.mp4Muxer = mp4Muxer;
    </script>
    <script>
        let scene, camera, renderer, group;
        let textureOffset = 0;
        let currentTexture = null;
        let currentTextureInside = null;
        let animationStartTime = 0;

        const defaultValues = {
            size: 280,
            radius: 60,
            rotX: -45,
            rotY: 0,
            rotZ: -45,
            speed: 0.5,
            offsetX: 0,
            offsetY: 0
        };

        const state = {
            text: 'KRC GENK  ',
            canvasWidth: 1920,
            canvasHeight: 1080,
            size: 280,
            radius: 60,
            rotX: -45,
            rotY: 0,
            rotZ: -45,
            speed: 0.5,
            bgColor: '82CDFF',
            fgColor: '07144a',
            zoom: 1,
            offsetX: 0,
            offsetY: 0,
            showGrid: false,
            verticalMode: false,
            repeat: 2,
            verticalRepeat: 3,
            easingP1: { x: 0.25, y: 0.25 },
            easingP2: { x: 0.75, y: 0.75 }
        };

        // Easing editor state
        let easingCanvas, easingCtx;
        let draggingHandle = null;

        function scaleCanvasToFit() {
            const container = document.getElementById('canvas-container');
            const canvas = renderer.domElement;

            requestAnimationFrame(() => {
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                const scaleX = containerWidth / state.canvasWidth;
                const scaleY = containerHeight / state.canvasHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9;

                canvas.style.transform = `scale(${scale})`;
                updateGrid();
            });
        }

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(parseInt(state.bgColor, 16));

            camera = new THREE.PerspectiveCamera(45, state.canvasWidth / state.canvasHeight, 1, 2000);
            camera.position.set(0, 0, 800);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(state.canvasWidth, state.canvasHeight);
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dir = new THREE.DirectionalLight(0xffffff, 0.5);
            dir.position.set(1, 1, 1);
            scene.add(dir);

            group = new THREE.Group();
            scene.add(group);

            scaleCanvasToFit();

            document.fonts.ready.then(() => {
                build();
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY * -0.001;
                state.zoom = Math.max(0.1, Math.min(3, state.zoom + delta));
                group.scale.set(state.zoom, state.zoom, state.zoom);

                const basePixelRatio = window.devicePixelRatio || 1;
                if (state.zoom > 1) {
                    const zoomPixelRatio = Math.min(basePixelRatio * state.zoom, basePixelRatio * 2);
                    renderer.setPixelRatio(zoomPixelRatio);
                } else {
                    renderer.setPixelRatio(basePixelRatio);
                }
            });

            window.addEventListener('resize', () => {
                scaleCanvasToFit();
            });

            let drag = false, prev = {x:0, y:0};
            renderer.domElement.onmousedown = e => { drag = true; prev = {x: e.clientX, y: e.clientY}; };
            document.onmousemove = e => {
                if (!drag) return;
                state.rotY += (e.clientX - prev.x) * 0.5;
                state.rotX = Math.max(-90, Math.min(90, state.rotX - (e.clientY - prev.y) * 0.3));
                document.getElementById('rotXSlider').value = state.rotX;
                document.getElementById('rotYSlider').value = state.rotY;
                document.getElementById('rotXValue').value = Math.round(state.rotX);
                document.getElementById('rotYValue').value = Math.round(state.rotY);
                updateRotation();
                prev = {x: e.clientX, y: e.clientY};
            };
            document.onmouseup = () => drag = false;

            // Touch gesture handling
            let touchState = { active: false, touches: [], initialDist: 0, initialAngle: 0, initialZoom: 1, initialRotZ: 0 };

            const getTouchDistance = (t1, t2) => Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
            const getTouchAngle = (t1, t2) => Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX) * (180 / Math.PI);
            const getTouchCenter = (t1, t2) => ({ x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 });

            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchState.active = true;
                touchState.touches = Array.from(e.touches);

                if (e.touches.length === 2) {
                    touchState.initialDist = getTouchDistance(e.touches[0], e.touches[1]);
                    touchState.initialAngle = getTouchAngle(e.touches[0], e.touches[1]);
                    touchState.initialZoom = state.zoom;
                    touchState.initialRotZ = state.rotZ;
                } else if (e.touches.length === 1) {
                    prev = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!touchState.active) return;

                if (e.touches.length === 2) {
                    // Pinch zoom
                    const currentDist = getTouchDistance(e.touches[0], e.touches[1]);
                    const scale = currentDist / touchState.initialDist;
                    state.zoom = Math.max(0.1, Math.min(3, touchState.initialZoom * scale));
                    group.scale.set(state.zoom, state.zoom, state.zoom);

                    // Two-finger rotation
                    const currentAngle = getTouchAngle(e.touches[0], e.touches[1]);
                    const angleDelta = currentAngle - touchState.initialAngle;
                    state.rotZ = touchState.initialRotZ - angleDelta;
                    document.getElementById('rotZSlider').value = state.rotZ;
                    document.getElementById('rotZValue').value = Math.round(state.rotZ);
                    updateRotation();
                } else if (e.touches.length === 1) {
                    // Single finger drag for X/Y rotation
                    const touch = e.touches[0];
                    state.rotY += (touch.clientX - prev.x) * 0.5;
                    state.rotX = Math.max(-90, Math.min(90, state.rotX - (touch.clientY - prev.y) * 0.3));
                    document.getElementById('rotXSlider').value = state.rotX;
                    document.getElementById('rotYSlider').value = state.rotY;
                    document.getElementById('rotXValue').value = Math.round(state.rotX);
                    document.getElementById('rotYValue').value = Math.round(state.rotY);
                    updateRotation();
                    prev = { x: touch.clientX, y: touch.clientY };
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchend', (e) => {
                if (e.touches.length === 0) {
                    touchState.active = false;
                } else if (e.touches.length === 1) {
                    prev = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            });

            animate();
        }

        function clearGroup() {
            while (group.children.length) {
                const c = group.children[0];
                group.remove(c);
                c.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                });
            }
        }

        function build() {
            clearGroup();

            const s = state.size;
            const r = Math.min(state.radius, s/2 - 5);

            createTextBand(s, s, r);

            updateRotation();
            updateOffset();
        }

        function createRoundedRectShape(w, h, r) {
            const shape = new THREE.Shape();
            const hw = w/2, hh = h/2;

            shape.moveTo(-hw + r, -hh);
            shape.lineTo(hw - r, -hh);
            shape.quadraticCurveTo(hw, -hh, hw, -hh + r);
            shape.lineTo(hw, hh - r);
            shape.quadraticCurveTo(hw, hh, hw - r, hh);
            shape.lineTo(-hw + r, hh);
            shape.quadraticCurveTo(-hw, hh, -hw, hh - r);
            shape.lineTo(-hw, -hh + r);
            shape.quadraticCurveTo(-hw, -hh, -hw + r, -hh);

            return shape;
        }

        function finishVerticalTextBand(points, perimeter, canvas, actualDepth) {
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.RepeatWrapping; // Wrap vertically for scrolling
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.needsUpdate = true;

            currentTexture = texture;

            const halfD = actualDepth / 2;

            const vertices = [];
            const uvs = [];
            const indices = [];

            let cumLength = 0;
            const totalLength = perimeter;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];

                if (i > 0) {
                    cumLength += points[i].distanceTo(points[i-1]);
                }
                // V varies along perimeter for vertical scrolling
                const v = Math.max(0, Math.min(1, 1 - (cumLength / totalLength)));

                vertices.push(p.x, p.y, halfD);
                vertices.push(p.x, p.y, -halfD);

                // U is constant (0 or 1 for front/back), V varies
                uvs.push(1, v);
                uvs.push(0, v);

                if (i > 0) {
                    const base = (i - 1) * 2;
                    indices.push(base, base + 3, base + 1);
                    indices.push(base, base + 2, base + 3);
                }
            }

            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geom.setIndex(indices);
            geom.computeVertexNormals();

            const matOutside = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.FrontSide
            });

            const bandMeshOutside = new THREE.Mesh(geom, matOutside);
            group.add(bandMeshOutside);

            const textureInside = texture.clone();
            textureInside.needsUpdate = true;
            currentTextureInside = textureInside;

            const uvsInside = [];
            cumLength = 0;
            for (let i = 0; i < points.length; i++) {
                if (i > 0) {
                    cumLength += points[i].distanceTo(points[i-1]);
                }
                const v = Math.max(0, Math.min(1, cumLength / totalLength));
                uvsInside.push(1, v);
                uvsInside.push(0, v);
            }

            const geomInside = new THREE.BufferGeometry();
            geomInside.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geomInside.setAttribute('uv', new THREE.Float32BufferAttribute(uvsInside, 2));
            geomInside.setIndex(indices);
            geomInside.computeVertexNormals();

            const matInside = new THREE.MeshBasicMaterial({
                map: textureInside,
                side: THREE.BackSide
            });

            const bandMeshInside = new THREE.Mesh(geomInside, matInside);
            group.add(bandMeshInside);

            return actualDepth;
        }

        function finishTextBand(points, perimeter, canvas, actualDepth) {
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.needsUpdate = true;

            currentTexture = texture;

            const halfD = actualDepth / 2;

            const vertices = [];
            const uvs = [];
            const indices = [];

            let cumLength = 0;
            const totalLength = perimeter;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];

                if (i > 0) {
                    cumLength += points[i].distanceTo(points[i-1]);
                }
                const u = Math.max(0, Math.min(1, 1 - (cumLength / totalLength)));

                vertices.push(p.x, p.y, halfD);
                vertices.push(p.x, p.y, -halfD);

                uvs.push(u, 1);
                uvs.push(u, 0);

                if (i > 0) {
                    const base = (i - 1) * 2;
                    indices.push(base, base + 3, base + 1);
                    indices.push(base, base + 2, base + 3);
                }
            }

            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geom.setIndex(indices);
            geom.computeVertexNormals();

            const matOutside = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.FrontSide
            });

            const bandMeshOutside = new THREE.Mesh(geom, matOutside);
            group.add(bandMeshOutside);

            const textureInside = texture.clone();
            textureInside.needsUpdate = true;
            currentTextureInside = textureInside;

            const uvsInside = [];
            cumLength = 0;
            for (let i = 0; i < points.length; i++) {
                if (i > 0) {
                    cumLength += points[i].distanceTo(points[i-1]);
                }
                const u = Math.max(0, Math.min(1, cumLength / totalLength));
                uvsInside.push(u, 1);
                uvsInside.push(u, 0);
            }

            const geomInside = new THREE.BufferGeometry();
            geomInside.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geomInside.setAttribute('uv', new THREE.Float32BufferAttribute(uvsInside, 2));
            geomInside.setIndex(indices);
            geomInside.computeVertexNormals();

            const matInside = new THREE.MeshBasicMaterial({
                map: textureInside,
                side: THREE.BackSide
            });

            const bandMeshInside = new THREE.Mesh(geomInside, matInside);
            group.add(bandMeshInside);

            return actualDepth;
        }

        function createTextBand(w, h, r) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const baseText = state.text.trim() + ' ';
            // Apply repeat for horizontal mode only
            const text = state.verticalMode ? baseText : baseText.repeat(state.repeat);
            const fontFamily = 'Genk, Arial Black, sans-serif';

            // Measure text to determine aspect ratio
            const refFontSize = 100;
            ctx.font = `${refFontSize}px ${fontFamily}`;
            const textWidth = ctx.measureText(text).width;
            const textAspect = textWidth / refFontSize;

            let shapeW, shapeH;
            if (state.verticalMode) {
                // Vertical mode: tall narrow shape with stacked text moving upward
                const wordsPerSide = state.verticalRepeat;
                const numLines = wordsPerSide * 4; // words per side × 4 sides

                // Calculate shape width based on text width - use higher resolution
                const fontSize = w * 4; // Larger font for higher resolution texture
                ctx.font = `${fontSize}px ${fontFamily}`;
                const metrics = ctx.measureText(text);
                const singleTextWidth = metrics.width;
                const ascent = metrics.actualBoundingBoxAscent || fontSize * 0.8;
                const descent = metrics.actualBoundingBoxDescent || fontSize * 0.2;
                const lineHeight = (ascent + descent) * 1.05; // Tighter line spacing

                // Shape dimensions: make it roughly square so each side gets equal words
                const scaleFactor = 6; // Scale down for 3D shape
                const sideLength = (lineHeight * wordsPerSide) / scaleFactor;
                shapeW = sideLength;
                shapeH = sideLength;

                const hw = shapeW/2, hh = shapeH/2;
                const rClamped = Math.max(1, Math.min(r, hw - 5, hh - 5));

                // Create the tall narrow path
                const path = new THREE.Path();
                path.moveTo(-hw + rClamped, hh);
                path.lineTo(hw - rClamped, hh);
                path.quadraticCurveTo(hw, hh, hw, hh - rClamped);
                path.lineTo(hw, -hh + rClamped);
                path.quadraticCurveTo(hw, -hh, hw - rClamped, -hh);
                path.lineTo(-hw + rClamped, -hh);
                path.quadraticCurveTo(-hw, -hh, -hw, -hh + rClamped);
                path.lineTo(-hw, hh - rClamped);
                path.quadraticCurveTo(-hw, hh, -hw + rClamped, hh);

                const points = path.getPoints(100);

                let perimeter = 0;
                for (let i = 1; i < points.length; i++) {
                    perimeter += points[i].distanceTo(points[i-1]);
                }
                perimeter += points[points.length - 1].distanceTo(points[0]);

                // Create texture with vertically stacked text
                canvas.width = Math.ceil(singleTextWidth);
                canvas.height = Math.ceil(lineHeight * numLines);

                ctx.fillStyle = '#' + state.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.font = `${fontSize}px ${fontFamily}`;
                ctx.fillStyle = '#' + state.fgColor;
                ctx.textBaseline = 'alphabetic';

                // Flip horizontally to correct texture orientation
                ctx.save();
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);

                // Draw text stacked vertically
                for (let i = 0; i < numLines; i++) {
                    const yPos = lineHeight * i + ascent;
                    ctx.fillText(text, 0, yPos);
                }

                ctx.restore();

                // Depth is based on text width (thickness of the band)
                const actualDepth = singleTextWidth / scaleFactor;

                return finishVerticalTextBand(points, perimeter, canvas, actualDepth);
            }

            // Horizontal mode: wide shape (original square)
            shapeW = w;
            shapeH = h;

            const hw = shapeW/2, hh = shapeH/2;
            // Clamp radius to fit the shape dimensions (ensure positive)
            const rClamped = Math.max(1, Math.min(r, hw - 5, hh - 5));

            const path = new THREE.Path();
            path.moveTo(-hw + rClamped, hh);
            path.lineTo(hw - rClamped, hh);
            path.quadraticCurveTo(hw, hh, hw, hh - rClamped);
            path.lineTo(hw, -hh + rClamped);
            path.quadraticCurveTo(hw, -hh, hw - rClamped, -hh);
            path.lineTo(-hw + rClamped, -hh);
            path.quadraticCurveTo(-hw, -hh, -hw, -hh + rClamped);
            path.lineTo(-hw, hh - rClamped);
            path.quadraticCurveTo(-hw, hh, -hw + rClamped, hh);

            const points = path.getPoints(100);

            let perimeter = 0;
            for (let i = 1; i < points.length; i++) {
                perimeter += points[i].distanceTo(points[i-1]);
            }
            perimeter += points[points.length - 1].distanceTo(points[0]);

            // textAspect already calculated at top of function
            const depth = perimeter / textAspect;

            const scale = 6;
            const fontSize = depth * scale * 0.75;

            ctx.font = `${fontSize}px ${fontFamily}`;
            const metrics = ctx.measureText(text);
            const actualTextWidth = metrics.width;

            const ascent = metrics.actualBoundingBoxAscent || fontSize * 0.8;
            const descent = metrics.actualBoundingBoxDescent || fontSize * 0.2;
            const textHeight = ascent + descent;

            canvas.width = Math.ceil(actualTextWidth);
            canvas.height = Math.ceil(textHeight * 1.1);

            const actualDepth = canvas.height / (scale * 0.75);

            ctx.fillStyle = '#' + state.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.fillStyle = '#' + state.fgColor;
            ctx.textBaseline = 'alphabetic';

            const yPos = (canvas.height + ascent - descent) / 2;

            ctx.fillText(text, 0, yPos);

            return finishTextBand(points, perimeter, canvas, actualDepth);
        }

        function updateRotation() {
            group.rotation.x = THREE.MathUtils.degToRad(state.rotX);
            group.rotation.y = THREE.MathUtils.degToRad(state.rotY);
            group.rotation.z = THREE.MathUtils.degToRad(state.rotZ);
        }

        function updateOffset() {
            group.position.set(state.offsetX, state.offsetY, 0);
        }

        function updateGrid() {
            const gridOverlay = document.getElementById('grid-overlay');
            if (!renderer) return;

            const canvas = renderer.domElement;

            if (state.showGrid) {
                gridOverlay.classList.add('visible');

                gridOverlay.setAttribute('width', state.canvasWidth);
                gridOverlay.setAttribute('height', state.canvasHeight);

                const canvasTransform = canvas.style.transform || 'scale(1)';
                gridOverlay.style.transform = `translate(-50%, -50%) ${canvasTransform}`;

                gridOverlay.innerHTML = '';

                const cellWidth = state.canvasWidth / 3;
                const cellHeight = state.canvasHeight / 3;

                for (let i = 1; i < 3; i++) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', cellWidth * i);
                    line.setAttribute('y1', 0);
                    line.setAttribute('x2', cellWidth * i);
                    line.setAttribute('y2', state.canvasHeight);
                    line.setAttribute('stroke', 'rgba(130, 205, 255, 0.5)');
                    line.setAttribute('stroke-width', '2');
                    gridOverlay.appendChild(line);
                }

                for (let i = 1; i < 3; i++) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', cellHeight * i);
                    line.setAttribute('x2', state.canvasWidth);
                    line.setAttribute('y2', cellHeight * i);
                    line.setAttribute('stroke', 'rgba(130, 205, 255, 0.5)');
                    line.setAttribute('stroke-width', '2');
                    gridOverlay.appendChild(line);
                }
            } else {
                gridOverlay.classList.remove('visible');
            }
        }

        function cubicBezier(t, p1, p2) {
            const cx = 3 * p1.x;
            const bx = 3 * (p2.x - p1.x) - cx;
            const ax = 1 - cx - bx;

            const cy = 3 * p1.y;
            const by = 3 * (p2.y - p1.y) - cy;
            const ay = 1 - cy - by;

            return ((ay * t + by) * t + cy) * t;
        }

        function solveCubicBezierX(x, p1, p2) {
            if (x <= 0) return 0;
            if (x >= 1) return 1;

            const cx = 3 * p1.x;
            const bx = 3 * (p2.x - p1.x) - cx;
            const ax = 1 - cx - bx;

            let t = x;
            for (let i = 0; i < 8; i++) {
                const currentX = ((ax * t + bx) * t + cx) * t;
                const currentSlope = (3 * ax * t + 2 * bx) * t + cx;
                if (Math.abs(currentSlope) < 1e-6) break;
                t -= (currentX - x) / currentSlope;
            }
            return t;
        }

        function applyEasing(x, p1, p2) {
            const t = solveCubicBezierX(x, p1, p2);
            return cubicBezier(t, p1, p2);
        }

        function drawEasingCurve() {
            if (!easingCanvas || !easingCtx) return;

            const rect = easingCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = 12;
            const gridSize = w - padding * 2;

            easingCtx.clearRect(0, 0, easingCanvas.width, easingCanvas.height);

            // Draw grid
            easingCtx.strokeStyle = '#334473';
            easingCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const x = padding + (gridSize / 4) * i;
                const y = padding + (gridSize / 4) * i;
                easingCtx.beginPath();
                easingCtx.moveTo(x, padding);
                easingCtx.lineTo(x, padding + gridSize);
                easingCtx.stroke();
                easingCtx.beginPath();
                easingCtx.moveTo(padding, y);
                easingCtx.lineTo(padding + gridSize, y);
                easingCtx.stroke();
            }

            const toCanvasX = (x) => padding + x * gridSize;
            const toCanvasY = (y) => padding + gridSize - y * gridSize;

            // Draw handle lines (from origin to control points)
            easingCtx.strokeStyle = '#82CDFF';
            easingCtx.lineWidth = 1;
            // Line from (0,0) to P1
            easingCtx.beginPath();
            easingCtx.moveTo(toCanvasX(0), toCanvasY(0));
            easingCtx.lineTo(toCanvasX(state.easingP1.x), toCanvasY(state.easingP1.y));
            easingCtx.stroke();
            // Line from (1,1) to P2
            easingCtx.beginPath();
            easingCtx.moveTo(toCanvasX(1), toCanvasY(1));
            easingCtx.lineTo(toCanvasX(state.easingP2.x), toCanvasY(state.easingP2.y));
            easingCtx.stroke();

            // Draw the cubic bezier curve
            easingCtx.beginPath();
            easingCtx.moveTo(toCanvasX(0), toCanvasY(0));
            easingCtx.bezierCurveTo(
                toCanvasX(state.easingP1.x), toCanvasY(state.easingP1.y),
                toCanvasX(state.easingP2.x), toCanvasY(state.easingP2.y),
                toCanvasX(1), toCanvasY(1)
            );
            easingCtx.stroke();

            // Draw handles
            const handleRadius = 'ontouchstart' in window ? 6 : 3;
            const drawHandle = (x, y) => {
                easingCtx.fillStyle = '#82CDFF';
                easingCtx.beginPath();
                easingCtx.arc(toCanvasX(x), toCanvasY(y), handleRadius, 0, Math.PI * 2);
                easingCtx.fill();
            };

            drawHandle(state.easingP1.x, state.easingP1.y);
            drawHandle(state.easingP2.x, state.easingP2.y);
            drawHandle(0, 0);
            drawHandle(1, 1);
        }

        function initEasingEditor() {
            easingCanvas = document.getElementById('easingCanvas');
            easingCtx = easingCanvas.getContext('2d');

            // Handle high-DPI displays
            const dpr = window.devicePixelRatio || 1;
            const rect = easingCanvas.getBoundingClientRect();
            easingCanvas.width = rect.width * dpr;
            easingCanvas.height = rect.height * dpr;
            easingCtx.scale(dpr, dpr);

            const padding = 12;

            const getGridSize = () => {
                const r = easingCanvas.getBoundingClientRect();
                return r.width - padding * 2;
            };

            const toCanvasCoords = (nx, ny) => {
                const gridSize = getGridSize();
                return {
                    x: padding + nx * gridSize,
                    y: padding + gridSize - ny * gridSize
                };
            };

            const fromCanvasCoords = (cx, cy) => {
                const gridSize = getGridSize();

                return {
                    x: Math.max(0, Math.min(1, (cx - padding) / gridSize)),
                    y: Math.max(0, Math.min(1, 1 - (cy - padding) / gridSize))
                };
            };

            const getHandleAt = (mouseX, mouseY) => {
                const p1Pos = toCanvasCoords(state.easingP1.x, state.easingP1.y);
                const p2Pos = toCanvasCoords(state.easingP2.x, state.easingP2.y);

                const dist1 = Math.hypot(mouseX - p1Pos.x, mouseY - p1Pos.y);
                const dist2 = Math.hypot(mouseX - p2Pos.x, mouseY - p2Pos.y);

                // Larger hit area for touch devices
                const hitRadius = 'ontouchstart' in window ? 25 : 15;

                if (dist1 < hitRadius) return 'p1';
                if (dist2 < hitRadius) return 'p2';
                return null;
            };

            easingCanvas.addEventListener('mousedown', (e) => {
                const rect = easingCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                draggingHandle = getHandleAt(mouseX, mouseY);
                if (draggingHandle) {
                    e.preventDefault();
                    drawEasingCurve();
                }
            });

            const handleMouseMove = (e) => {
                if (!draggingHandle) return;

                const rect = easingCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const normalized = fromCanvasCoords(mouseX, mouseY);

                if (draggingHandle === 'p1') {
                    state.easingP1.x = normalized.x;
                    state.easingP1.y = normalized.y;
                } else if (draggingHandle === 'p2') {
                    state.easingP2.x = normalized.x;
                    state.easingP2.y = normalized.y;
                }

                updateEasingInput();
                drawEasingCurve();
            };

            const handleMouseUp = () => {
                if (draggingHandle) {
                    draggingHandle = null;
                    drawEasingCurve();
                }
            };

            easingCanvas.addEventListener('mousemove', handleMouseMove);
            easingCanvas.addEventListener('mouseup', handleMouseUp);
            easingCanvas.addEventListener('mouseleave', handleMouseUp);

            document.addEventListener('mousemove', (e) => {
                if (draggingHandle) {
                    handleMouseMove(e);
                }
            });

            document.addEventListener('mouseup', handleMouseUp);

            // Touch support for easing curve
            easingCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = easingCanvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                draggingHandle = getHandleAt(touchX, touchY);
                if (draggingHandle) {
                    drawEasingCurve();
                }
            }, { passive: false });

            easingCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!draggingHandle) return;

                const touch = e.touches[0];
                const rect = easingCanvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                const normalized = fromCanvasCoords(touchX, touchY);

                if (draggingHandle === 'p1') {
                    state.easingP1.x = normalized.x;
                    state.easingP1.y = normalized.y;
                } else if (draggingHandle === 'p2') {
                    state.easingP2.x = normalized.x;
                    state.easingP2.y = normalized.y;
                }

                updateEasingInput();
                drawEasingCurve();
            }, { passive: false });

            easingCanvas.addEventListener('touchend', () => {
                if (draggingHandle) {
                    draggingHandle = null;
                    drawEasingCurve();
                }
            });

            drawEasingCurve();
        }

        function updateEasingInput() {
            const input = document.getElementById('easingInput');
            const p1x = Math.round(state.easingP1.x * 100) / 100;
            const p1y = Math.round(state.easingP1.y * 100) / 100;
            const p2x = Math.round(state.easingP2.x * 100) / 100;
            const p2y = Math.round(state.easingP2.y * 100) / 100;
            input.value = `${p1x}, ${p1y}, ${p2x}, ${p2y}`;
        }

        function parseEasingInput() {
            const input = document.getElementById('easingInput');
            const parts = input.value.split(',').map(s => parseFloat(s.trim()));

            if (parts.length === 4 && parts.every(p => !isNaN(p))) {
                state.easingP1.x = Math.max(0, Math.min(1, parts[0]));
                state.easingP1.y = Math.max(0, Math.min(1, parts[1]));
                state.easingP2.x = Math.max(0, Math.min(1, parts[2]));
                state.easingP2.y = Math.max(0, Math.min(1, parts[3]));
                drawEasingCurve();
            } else {
                updateEasingInput();
            }
        }

        function animate(timestamp) {
            requestAnimationFrame(animate);

            if (!animationStartTime) animationStartTime = timestamp;

            if (state.speed > 0) {
                const cycleDuration = 8000 / state.speed;
                const elapsed = (timestamp - animationStartTime) % cycleDuration;
                const linearProgress = elapsed / cycleDuration;

                const easedProgress = applyEasing(linearProgress, state.easingP1, state.easingP2);

                const offset = easedProgress;

                if (currentTexture) {
                    if (state.verticalMode) {
                        currentTexture.offset.y = -offset; // Bottom to top
                        currentTexture.offset.x = 0;
                    } else {
                        currentTexture.offset.x = offset;
                        currentTexture.offset.y = 0;
                    }
                }
                if (currentTextureInside) {
                    if (state.verticalMode) {
                        currentTextureInside.offset.y = -offset; // Bottom to top
                        currentTextureInside.offset.x = 0;
                    } else {
                        currentTextureInside.offset.x = offset;
                        currentTextureInside.offset.y = 0;
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // Sliders
        const sliders = [
            ['sizeSlider', 'sizeValue', 'size', ''],
            ['radiusSlider', 'radiusValue', 'radius', ''],
            ['rotXSlider', 'rotXValue', 'rotX', ''],
            ['rotYSlider', 'rotYValue', 'rotY', ''],
            ['rotZSlider', 'rotZValue', 'rotZ', ''],
            ['speedSlider', 'speedValue', 'speed', ''],
            ['offsetXSlider', 'offsetXValue', 'offsetX', ''],
            ['offsetYSlider', 'offsetYValue', 'offsetY', '']
        ];

        sliders.forEach(([id, valId, key, suf]) => {
            const slider = document.getElementById(id);
            const valueInput = document.getElementById(valId);

            slider.addEventListener('input', e => {
                state[key] = parseFloat(e.target.value);
                valueInput.value = e.target.value + suf;
                if (key === 'rotX' || key === 'rotY' || key === 'rotZ') updateRotation();
                else if (key === 'offsetX' || key === 'offsetY') updateOffset();
                else if (key !== 'speed') build();
            });

            valueInput.addEventListener('input', e => {
                const numValue = parseFloat(e.target.value.replace(suf, ''));
                if (!isNaN(numValue)) {
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const clampedValue = Math.max(min, Math.min(max, numValue));
                    state[key] = clampedValue;
                    slider.value = clampedValue;
                    valueInput.value = clampedValue + suf;
                    if (key === 'rotX' || key === 'rotY' || key === 'rotZ') updateRotation();
                    else if (key === 'offsetX' || key === 'offsetY') updateOffset();
                    else if (key !== 'speed') build();
                }
            });
        });

        document.getElementById('textInput').addEventListener('input', e => {
            state.text = e.target.value || 'TYPE ';
            build();
        });

        // Reset buttons
        document.querySelectorAll('.reset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const key = btn.dataset.reset;
                const defaultValue = defaultValues[key];
                state[key] = defaultValue;

                const slider = document.getElementById(key + 'Slider');
                const valueInput = document.getElementById(key + 'Value');

                slider.value = defaultValue;
                valueInput.value = defaultValue;

                if (key === 'rotX' || key === 'rotY' || key === 'rotZ') {
                    updateRotation();
                } else if (key === 'offsetX' || key === 'offsetY') {
                    updateOffset();
                } else if (key !== 'speed') {
                    build();
                }
            });
        });

        // Grid toggle
        document.getElementById('gridToggle').addEventListener('change', e => {
            state.showGrid = e.target.checked;
            updateGrid();
        });

        // Vertical mode toggle
        document.getElementById('verticalToggle').addEventListener('change', e => {
            state.verticalMode = e.target.checked;
            if (state.verticalMode) {
                // Set rotation to x:0, y:-90, z:0 for vertical mode
                state.rotX = 0;
                state.rotY = -90;
                state.rotZ = 0;
                // Update repeat display to show vertical repeat value
                document.getElementById('repeatValue').textContent = state.verticalRepeat + '×';
            } else {
                // Reset to default rotation for horizontal mode
                state.rotX = defaultValues.rotX;
                state.rotY = defaultValues.rotY;
                state.rotZ = defaultValues.rotZ;
                // Update repeat display to show horizontal repeat value
                document.getElementById('repeatValue').textContent = state.repeat + '×';
            }
            // Update slider displays
            document.getElementById('rotXSlider').value = state.rotX;
            document.getElementById('rotXValue').value = state.rotX;
            document.getElementById('rotYSlider').value = state.rotY;
            document.getElementById('rotYValue').value = state.rotY;
            document.getElementById('rotZSlider').value = state.rotZ;
            document.getElementById('rotZValue').value = state.rotZ;
            build();
        });

        // Repeat controls (works for both horizontal and vertical modes)
        document.getElementById('repeatMinus').addEventListener('click', () => {
            if (state.verticalMode) {
                // Vertical mode: min 3
                if (state.verticalRepeat > 3) {
                    state.verticalRepeat--;
                    document.getElementById('repeatValue').textContent = state.verticalRepeat + '×';
                    build();
                }
            } else {
                // Horizontal mode: min 1
                if (state.repeat > 1) {
                    state.repeat--;
                    document.getElementById('repeatValue').textContent = state.repeat + '×';
                    build();
                }
            }
        });

        document.getElementById('repeatPlus').addEventListener('click', () => {
            if (state.verticalMode) {
                // Vertical mode: max 7
                if (state.verticalRepeat < 7) {
                    state.verticalRepeat++;
                    document.getElementById('repeatValue').textContent = state.verticalRepeat + '×';
                    build();
                }
            } else {
                // Horizontal mode: max 5
                if (state.repeat < 5) {
                    state.repeat++;
                    document.getElementById('repeatValue').textContent = state.repeat + '×';
                    build();
                }
            }
        });

        // Easing input
        document.getElementById('easingInput').addEventListener('blur', parseEasingInput);
        document.getElementById('easingInput').addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                parseEasingInput();
                e.target.blur();
            }
        });

        // Background color swatches
        document.querySelectorAll('#bgColorSwatches .color-swatch').forEach(swatch => {
            swatch.addEventListener('click', e => {
                document.querySelectorAll('#bgColorSwatches .color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                state.bgColor = swatch.dataset.color;
                scene.background = new THREE.Color(parseInt(state.bgColor, 16));
                build();
            });
        });

        // Foreground color swatches
        document.querySelectorAll('#fgColorSwatches .color-swatch').forEach(swatch => {
            swatch.addEventListener('click', e => {
                document.querySelectorAll('#fgColorSwatches .color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                state.fgColor = swatch.dataset.color;
                build();
            });
        });

        // Canvas size buttons
        document.querySelectorAll('#sizeButtons .size-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                document.querySelectorAll('#sizeButtons .size-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const [width, height] = btn.dataset.size.split('x').map(Number);
                state.canvasWidth = width;
                state.canvasHeight = height;

                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);

                scaleCanvasToFit();
            });
        });

        // Export PNG
        document.getElementById('exportPNG').addEventListener('click', () => {
            renderer.render(scene, camera);

            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'krcg-graphic-' + Date.now() + '.png';
            link.href = dataURL;
            link.click();
        });

        // Export MP4
        let isRecording = false;
        let muxer;
        let videoEncoder;
        let frameNumber = 0;
        let totalFrames = 0;
        let captureFrameId = null;

        document.getElementById('exportMP4').addEventListener('click', async () => {
            const btn = document.getElementById('exportMP4');

            if (isRecording) {
                return;
            }

            isRecording = true;
            frameNumber = 0;

            const cycleDuration = 8000 / state.speed;
            totalFrames = Math.ceil((cycleDuration / 1000) * 60);

            btn.textContent = 'Exporting...';
            btn.style.background = '#82CDFF';
            btn.style.color = '#001550';
            btn.disabled = true;

            await new Promise(resolve => {
                const check = () => {
                    if (window.mp4Muxer) resolve();
                    else setTimeout(check, 50);
                };
                check();
            });

            const { Muxer, ArrayBufferTarget } = window.mp4Muxer;

            // Use logical canvas dimensions, not pixel dimensions (which include devicePixelRatio)
            const videoWidth = state.canvasWidth;
            const videoHeight = state.canvasHeight;

            const target = new ArrayBufferTarget();
            muxer = new Muxer({
                target,
                video: {
                    codec: 'avc',
                    width: videoWidth,
                    height: videoHeight
                },
                fastStart: 'in-memory',
                firstTimestampBehavior: 'offset'
            });

            let encoderFailed = false;
            videoEncoder = new VideoEncoder({
                output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
                error: e => {
                    console.error('Encoder error:', e);
                    encoderFailed = true;
                    isRecording = false;
                    alert('Video encoder failed: ' + e.message);
                    btn.textContent = 'MP4';
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.disabled = false;
                }
            });

            try {
                videoEncoder.configure({
                    codec: 'avc1.640033',
                    width: videoWidth,
                    height: videoHeight,
                    bitrate: 15_000_000,
                    framerate: 60
                });

                await new Promise(resolve => setTimeout(resolve, 100));

                if (encoderFailed || videoEncoder.state !== 'configured') {
                    throw new Error('Encoder failed to configure.');
                }
            } catch (e) {
                console.error('Failed to configure encoder:', e);
                alert('Failed to start video export: ' + e.message);
                isRecording = false;
                btn.textContent = 'MP4';
                btn.style.background = '';
                btn.style.color = '';
                return;
            }

            const captureFrame = () => {
                if (encoderFailed) {
                    return;
                }

                if (frameNumber >= totalFrames) {
                    isRecording = false;

                    videoEncoder.flush().then(() => {
                        videoEncoder.close();
                        muxer.finalize();
                        const { buffer } = muxer.target;
                        const blob = new Blob([buffer], { type: 'video/mp4' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = 'krcg-graphic-' + Date.now() + '.mp4';
                        link.href = url;
                        link.click();
                        URL.revokeObjectURL(url);
                        btn.textContent = 'MP4';
                        btn.style.background = '';
                        btn.style.color = '';
                        btn.disabled = false;
                    }).catch(e => {
                        console.error('Error finalizing video:', e);
                        alert('Error creating video: ' + e.message);
                        btn.textContent = 'MP4';
                        btn.style.background = '';
                        btn.style.color = '';
                        btn.disabled = false;
                    });
                    return;
                }

                if (videoEncoder.state !== 'configured') {
                    isRecording = false;
                    return;
                }

                if (videoEncoder.encodeQueueSize > 30) {
                    captureFrameId = setTimeout(captureFrame, 10);
                    return;
                }

                const linearProgress = frameNumber / totalFrames;
                const easedProgress = applyEasing(linearProgress, state.easingP1, state.easingP2);

                if (currentTexture) {
                    if (state.verticalMode) {
                        currentTexture.offset.y = -easedProgress; // Bottom to top
                        currentTexture.offset.x = 0;
                    } else {
                        currentTexture.offset.x = easedProgress;
                        currentTexture.offset.y = 0;
                    }
                }
                if (currentTextureInside) {
                    if (state.verticalMode) {
                        currentTextureInside.offset.y = -easedProgress; // Bottom to top
                        currentTextureInside.offset.x = 0;
                    } else {
                        currentTextureInside.offset.x = easedProgress;
                        currentTextureInside.offset.y = 0;
                    }
                }

                renderer.render(scene, camera);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = videoWidth;
                tempCanvas.height = videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                // Scale from high-DPI source to logical destination
                tempCtx.drawImage(
                    renderer.domElement,
                    0, 0, renderer.domElement.width, renderer.domElement.height,
                    0, 0, videoWidth, videoHeight
                );

                const frame = new VideoFrame(tempCanvas, {
                    timestamp: (frameNumber * 1_000_000) / 60
                });

                videoEncoder.encode(frame, { keyFrame: frameNumber % 60 === 0 });
                frame.close();

                frameNumber++;

                captureFrameId = requestAnimationFrame(captureFrame);
            };

            captureFrame();
        });

        // Load custom font then initialize
        document.fonts.load('100px Genk').then(() => {
            init();
            initEasingEditor();
        }).catch(() => {
            init();
            initEasingEditor();
        });
    </script>
</body>
</html>
